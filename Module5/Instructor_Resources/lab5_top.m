% this code will model the operation of Lab 5 - the full Digital
% Downconverter.  This model will be constructed in class in groups. Don't
% leave class until this makes sense; everyone should be ready to go build
% the FPGA after this.

%% FIRST - lets set some global parameters, our sample rate, and the number of output samples to simulate
fs_input = 125e6;
OVERALL_FILTER_DECIMATION_RATE = 64*40; 
fs_output = fs_input / OVERALL_FILTER_DECIMATION_RATE;
num_output_samples = 1024; % this is the desired number of output samples to see in the simulation
num_input_samples = num_output_samples * OVERALL_FILTER_DECIMATION_RATE;
n = linspace(1,num_input_samples,num_input_samples);
PLACEHOLDER = 2000*randn(num_input_samples,1);
freqs = (0:fs_input/num_input_samples:fs_input-fs_input/num_input_samples) - fs_input/2;
freqs_low = freqs(1:OVERALL_FILTER_DECIMATION_RATE:end)./OVERALL_FILTER_DECIMATION_RATE;

%% here we will construct the scenario.  Where is the radio "tuned" and what input signal is provided from the fake-ADC
radio_tune_frequency = -30e6; % - requested frequency to shift DOWN
input_signal_frequency = 30.001e6;

%% Create the input signal from the "antenna/adc".  Since this will actually be a DDS in practice, it may be convenient to 
%% set the amplitude of this signal to be the same as what you will get from the DDS (you are quite familiar with that by now)
% signal from ADC
sig_from_antenna = round(16384 * sin(2*pi*n*input_signal_frequency/fs_input));

% now construct the signal that you will use for tuning the radio.  This
% should be either an complex exponential, or it can be 2 separate real
% signals, one for sine, one for cosine.  The goal though should be that
% this signal, when multiplied by the input signal, will shift the input
% signal down by the radio_tune_frequency. This model will be most helpful
% if you make this signal like what you expect to get from the DDS itself
% (again, you are pretty familiar with what it does by this point, so you
% don't need to use the bit accurate model for the DDS, just sine and cos
% are fine..
tune_signal = 2^14*exp(2i*pi*n*radio_tune_frequency/fs_input);
tuner_dds_real = real(tune_signal);
tuner_dds_imag = imag(tune_signal);

% Now, multiply the two signals together in the same way that you will in the fpga
mixer_output = sig_from_antenna.*tune_signal / 2^14; % truncate by 14 bits
mixer_output_real = tuner_dds_real.*sig_from_antenna;
mixer_output_imag = tuner_dds_imag.*sig_from_antenna;


% Now, filter the result with the filter from Lab 4, you can use the bit
% accurate model, or use the filters as you designed them in matlab and
% decimate accordingly
% ....

h1 = filter1(); % use freqz to visualize filter
h2 = filter2();

filterOutput = filter(h2.Numerator,1,filter(h1.Numerator,1,mixer_output));
filter_output_real = decimate(real(filterOutput),OVERALL_FILTER_DECIMATION_RATE);
filter_output_imag = decimate(imag(filterOutput),OVERALL_FILTER_DECIMATION_RATE);

% plot the various stages for understanding
% time domain on left, frequency domain on right

subplot(4,2,1);
plot(sig_from_antenna);
title('Signal from Antenna');
subplot(4,2,2);
plot(freqs,fftshift(20*log10(abs(fft(sig_from_antenna)))));
title('FFT of Signal from Antenna');
subplot(4,2,3);
tuner_dds_complex = tuner_dds_real + j*tuner_dds_imag;
plot(tuner_dds_real);
hold on;
plot(tuner_dds_imag);
hold off;
title('Tuner DDS');
subplot(4,2,4);
plot(freqs,fftshift(20*log10(abs(fft(tuner_dds_complex)))));
title('FFT of tuner DDS');
subplot(4,2,5);
plot(mixer_output_real);
hold on;
plot(mixer_output_imag);
hold off;
title('Mixer Output');
subplot(4,2,6);
mixer_output_complex = mixer_output_real + j*mixer_output_imag;
plot(freqs,fftshift(20*log10(abs(fft(mixer_output_complex)))));
title('FFT of mixer output');
subplot(4,2,7);
plot(filter_output_real);
hold on;
plot(filter_output_imag);
hold off;
title('Filter Output');
subplot(4,2,8);
% final result will be half magnitude since filtering out one half.
% effectively two tones, one is at A and one at 2A
filter_output_complex = filter_output_real + j*filter_output_imag;
plot(freqs_low,fftshift(20*log10(abs(fft(filter_output_complex)))));
title('FFT of filter output');

function Hd = filter1
%FILTER1 Returns a discrete-time filter object.

% MATLAB Code
% Generated by MATLAB(R) 9.10 and Signal Processing Toolbox 8.6.
% Generated on: 07-Mar-2023 13:56:07

% Equiripple Lowpass filter designed using the FIRPM function.

% All frequency values are in Hz.
Fs = 125000000;  % Sampling Frequency

Fpass = 576000;          % Passband Frequency
Fstop = 2549000;         % Stopband Frequency
Dpass = 0.028774368332;  % Passband Ripple
Dstop = 0.0001;          % Stopband Attenuation
dens  = 20;              % Density Factor

% Calculate the order from the parameters using FIRPMORD.
[N, Fo, Ao, W] = firpmord([Fpass, Fstop]/(Fs/2), [1 0], [Dpass, Dstop]);

% Calculate the coefficients using the FIRPM function.
b  = firpm(N, Fo, Ao, W, {dens});
Hd = dfilt.dffir(b);
end

function Hd = filter2
%FILTER2 Returns a discrete-time filter object.

% MATLAB Code
% Generated by MATLAB(R) 9.10 and Signal Processing Toolbox 8.6.
% Generated on: 07-Mar-2023 13:59:29

% Equiripple Lowpass filter designed using the FIRPM function.

% All frequency values are in Hz.
Fs = 3125000;  % Sampling Frequency

Fpass = 18000;           % Passband Frequency
Fstop = 30000;           % Stopband Frequency
Dpass = 0.028774368332;  % Passband Ripple
Dstop = 0.0001;          % Stopband Attenuation
dens  = 20;              % Density Factor

% Calculate the order from the parameters using FIRPMORD.
[N, Fo, Ao, W] = firpmord([Fpass, Fstop]/(Fs/2), [1 0], [Dpass, Dstop]);

% Calculate the coefficients using the FIRPM function.
b  = firpm(N, Fo, Ao, W, {dens});
Hd = dfilt.dffir(b);
end